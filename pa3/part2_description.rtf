{\rtf1\ansi\ansicpg1252\cocoartf1671
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Traffic Light Controller\
\
We have eight states in this FSM. Note that we begin at s0/IDLE, and end at S10. We managed to reduce redundancies in code by combining some setting states with enable states for when lights switch and timers turn on. We implemented a Mealy machine, primarily exemplified through the use of last_green and next_ped, where the present state was determined as a result of both the prior state and its input values, those values being last_green and next_ped. \
\
Without going into the logic of the machine (it is exactly as prescribed on the spec), here are some key design choices we made aside from implementing a Mealy machine. First, we made sure to preserve the value of outputs throughout states. This ensures that we don\'92t forget a last_green, which ensures that we keep the alternating cadence of our system in check. This  was our alternative since we didn\'92t truly have a \'93memory\'94 device\'97 our memory implantation was holding those values to the prior clock cycle value (unless it needed to be changed) for every clock cycle. Another design choice was the amount of time the timer was to be held. We saw that there was an extra clock cycle between a timer\'92s enable and the timer\'92s finishing, and this is because it takes one clock cycle for enable to go high and load to go low after having loaded in the proper values to the timer. To solve this, since we know we had 1 elapsed clock cycle, we made our timers elapse for one second less, e.g. the pedestrian state sends 4\'92d14 instead of 4\'92d15 to the timer, since the extra second shouldn\'92t be double counted. \
\
}